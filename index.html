<!DOCTYPE html>
<html>
<head>
    <title>Kiosk Web Content</title>
</head>
<body>
<h1>Управление Android из JS</h1>

<button onclick="sendToast()">Показать Android Toast</button>
<button onclick="requestDeviceId()">Запросить ID устройства</button>
<button onclick="printNewReceipt()">Напечатать Чек (Полностью в JS)</button>

<p id="device-id-display">ID устройства: Ожидание...</p>
<p id="native-status" style="color: red; font-weight: bold;">Статус: Готов!!!!</p>

<script>
    const PRINTER_VID = 1008;
    const PRINTER_PID = 15127;

    function sendToast() {
        // Проверяем, существует ли объект AndroidBridge (доступен только в WebView)
        if (typeof AndroidBridge !== 'undefined') {
            AndroidBridge.showToast('Успешно вызвано из HTML!');
        } else {
            alert('Объект AndroidBridge недоступен (не в WebView).');
        }
    }

    function requestDeviceId() {
        if (typeof AndroidBridge !== 'undefined') {
            // Прямой вызов Kotlin-метода, который возвращает значение
            const deviceId = AndroidBridge.getDeviceId();

            document.getElementById('device-id-display').innerText =
                'ID устройства: ' + deviceId;

        } else {
            document.getElementById('device-id-display').innerText =
                'ID устройства: Ошибка (Bridge недоступен).';
        }
    }


    // ВАЖНАЯ ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ БАЙТОВ
    function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            // Мы используем String.fromCharCode для корректной работы с сырыми байтами
            binary += String.fromCharCode(bytes[i]);
        }
// Кодируем полученную строку в Base64
        return btoa(binary);
    }

    function printNewReceipt() {
        if (typeof AndroidBridge === 'undefined') {
            handleNativeResult("Error: AndroidBridge === null");
            return;
        }

        const esc = 27;
        const formFeed = 12; // Команда выброса страницы (печать)

        // --- 1. ФОРМИРОВАНИЕ КОМАНД PJL/PCL ---

        // Универсальная последовательность для начала и конца PJL (Universal Exit Language, UEL)
        const UEL = new TextEncoder().encode(String.fromCharCode(esc) + "%-12345X");
        const CR_LF = new TextEncoder().encode("\r\n"); // Обязательный CRLF

        let printCommands = [];

        // 1. НАЧАЛО ЗАДАНИЯ (PJL Header)
        printCommands.push(...UEL); // ESC %-12345X
        printCommands.push(...new TextEncoder().encode("@PJL JOB\r\n"));

        // 2. УКАЗАНИЕ ЯЗЫКА (Переключение в режим PCL)
        printCommands.push(...new TextEncoder().encode("@PJL ENTER LANGUAGE=PCL\r\n"));

        // 3. КОМАНДЫ PCL

        // ESC E: Сброс PCL-состояния принтера (обязательно)
        printCommands.push(esc, 69);

        // ESC &l1O: Установка ориентации в Портретную (Portrait)
        printCommands.push(esc, 38, 108, 49, 79);

        // ESC (s3B: Установка жирного шрифта (если нужно, иначе просто текст)
        // printCommands.push(esc, 40, 115, 51, 66); // Можно добавить для жирного текста

        const textToPrint =
            "*** ТЕСТОВАЯ ПЕЧАТЬ HP LASERJET M1005 ***\r\n" +
            "Устройство VID: 1008, PID: 15127\r\n" +
            "PCL-команды получены и обработаны.\r\n" +
            "---------------------------------------\r\n" +
            "Если вы видите этот текст, то PJL/PCL работает!\r\n\r\n";

        // 4. Отправка текста (Важно: PCL требует \r\n для корректного перевода строки)
        printCommands.push(...new TextEncoder().encode(textToPrint));

        // 5. Выброс страницы (Form Feed) - инициирует фактическую печать
        printCommands.push(formFeed);

        // НОВОЕ: Переключение из режима PCL обратно в PJL (Обязательно для закрытия сессии)
        printCommands.push(...UEL); // ESC %-12345X

        // 6. КОНЕЦ ЗАДАНИЯ (PJL End)
        printCommands.push(...new TextEncoder().encode("@PJL EOJ\r\n")); // End Of Job

        // НОВОЕ: Отправьте еще один UEL для абсолютного завершения (иногда требуется)
        printCommands.push(...UEL); // ESC %-12345X

        const dataBuffer = new Uint8Array(printCommands);

        // --- 2. Кодирование в Base64 ---
        const base64Data = arrayBufferToBase64(dataBuffer);

        // --- 3. Формирование универсального JSON-объекта команды ---
        const command = {
            action: "USB_IO_COMMAND",
            parameters: {
                vid: PRINTER_VID,
                pid: PRINTER_PID,
                data: base64Data // Байты PCL-команд в Base64
            }
        };

        try {
            AndroidBridge.executeCommand(JSON.stringify(command));
            document.getElementById('native-status').innerText = "Статус: Команда отправлена на обработку...";
            document.getElementById('native-status').style.color = "orange";
        } catch (e) {
            console.error("Ошибка вызова Bridge:", e);
        }
    }

    /**
     * Принимает результат выполнения команды от Kotlin.
     * @param result Сообщение об успехе или ошибке.
     */
    function handleNativeResult(result) {
        const statusElement = document.getElementById('native-status');

        statusElement.innerText = "Статус: " + result;

        // Если сообщение содержит "Error" (например, USB Error), делаем его красным
        if (result.includes("Error")) {
            statusElement.style.color = "red";
            console.error("Нативная ошибка:", result);
        } else {
            statusElement.style.color = "green";
            console.log("Нативный успех:", result);
        }
    }
</script>
</body>
</html>
