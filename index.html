<!DOCTYPE html>
<html>
<head>
    <title>Kiosk Web Content</title>
</head>
<body>
<h1>Инициализация Киоска</h1>
<div id="usb-device-list">
    <p>Загрузка статуса USB...?!</p>
</div>
<script>
    const deviceListContainer = document.getElementById('usb-device-list');

    // Функция для преобразования строки (если Kotlin возвращает toString())
    // В реальном приложении здесь должен быть JSON.parse(kotlinResult)
    function parseKotlinList(str) {
        return JSON.parse(str);
        // Заглушка, если нет JSON-библиотеки в Kotlin
        // Предполагаем, что вам нужно будет настроить парсинг под ваш строковый формат.
        // Идеально: использовать JSON.parse().
        return [{vid: 1008, pid: 15127, deviceName: "HP Printer", hasPermission: false}];
    }

    // 1. ПОЛУЧЕНИЕ СПИСКА УСТРОЙСТВ
    function fetchUsbDevices() {
        const command = {
            action: "USB_IO_COMMAND",
            parameters: { action_type: "GET_DEVICES" }
        };

        // !!! НОВЫЙ ВЫЗОВ: Передаем имя функции-обработчика !!!
        AndroidBridge.executeCommandAsync(JSON.stringify(command), "handleUsbResult");
    }

    // JS: Функция, которая получит ответ от Kotlin
    function handleUsbResult(resultString) {
        if (!resultString || resultString.startsWith("USB_ERROR:")) {
            deviceListContainer.innerHTML = `<p style='color: red;'>Ошибка Bridge/Kotlin: ${resultString || 'Пустой ответ'}</p>`;
            return;
        }

        try {
            const devices = JSON.parse(resultString);
            renderDeviceList(devices);
        } catch (e) {
            deviceListContainer.innerHTML = `<p style='color: red;'>Ошибка парсинга JSON: ${e.message}</p>`;
        }
    }

    // 2. ОТПРАВКА ЗАПРОСА РАЗРЕШЕНИЯ (АСИНХРОННАЯ ВЕРСИЯ)
    function requestPermission(vid, pid) {
        const command = {
            action: "USB_IO_COMMAND",
            parameters: { action_type: "REQUEST_PERMISSION", vid: vid, pid: pid }
        };

        const button = document.getElementById(`btn-${vid}-${pid}`);
        button.disabled = true;
        button.innerText = 'Ожидание подтверждения...';

        try {
            // !!! ИСПРАВЛЕНИЕ !!!: Используем handleOperationStatus для получения статуса
            const launchStatus = AndroidBridge.executeCommandAsync(
                JSON.stringify(command),
                "handleOperationStatus" // <--- НОВАЯ ФУНКЦИЯ CALLBACK
            );

            console.log("Запрос разрешения запущен, статус:", launchStatus);

        } catch (e) {
            alert("Критическая ошибка запуска Bridge: " + e.message);
            button.disabled = false;
            button.innerText = 'Запросить разрешение';
        }
    }

    // 3. ОТОБРАЖЕНИЕ СПИСКА В HTML
    function renderDeviceList(devices) {
        let html = '<h3>Статус USB-устройств:</h3><ul>';

        devices.forEach(device => {
            const status = device.hasPermission ? '✅ Разрешено' : '❌ Нет разрешения';
            const buttonText = device.hasPermission ? 'Подтверждено' : 'Запросить разрешение';
            const buttonId = `btn-${device.vid}-${device.pid}`;

            html += `
                <li>
                    <strong>${device.deviceName}</strong> (VID:${device.vid}, PID:${device.pid})
                    — Статус: ${status}
                    <button
                        id="${buttonId}"
                        onclick="requestPermission(${device.vid}, ${device.pid})"
                        ${device.hasPermission ? 'disabled' : ''}>
                        ${buttonText}
                    </button>
                </li>
            `;
        });

        html += '</ul>';
        deviceListContainer.innerHTML = html;
    }

    // JS: Функция, которая получит результат выполнения операций (REQUEST_PERMISSION, Печать)
    function handleOperationStatus(resultString) {
        if (resultString && resultString.startsWith("USB Error:")) {
            alert("Ошибка операции: " + resultString);
        } else {
            alert("Операция завершена: " + resultString);
        }

        // После получения статуса (Успех/Ошибка), всегда обновляем список,
        // чтобы увидеть новый статус разрешения.
        fetchUsbDevices();
    }

    // Запуск при загрузке страницы
    fetchUsbDevices();
</script>
</body>
</html>
